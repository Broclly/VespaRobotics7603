// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.photonvision.*;
import org.photonvision.targeting.PhotonPipelineResult;
import org.photonvision.targeting.PhotonTrackedTarget;

// motors
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;

import java.util.List;



/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
    /**
     *
     * This function is run when the robot is first started up and should be used for any
     * initialization code.
     */
    VictorSPX leftMotor2 = new VictorSPX(2);
    VictorSPX rightMotor1 = new VictorSPX(3);
    VictorSPX rightMotor2 = new VictorSPX(4);
    VictorSPX leftMotor1 = new VictorSPX(1);
    
    PhotonCamera camera = new PhotonCamera("C270_HD_WEBCAM");

    public void tank(double LMS, double RMS){
        // change format for motor controler
        //double offset = 0.04 - (LMS/25);
        //System.out.println("tanking");
        leftMotor1.set(ControlMode.PercentOutput, LMS );
        leftMotor2.set(ControlMode.PercentOutput, LMS );

        rightMotor1.set(ControlMode.PercentOutput, -RMS);
        rightMotor2.set(ControlMode.PercentOutput, -RMS);
        // driveRobot(LMS, -RMS);
    }
    public void arcade(double Speed, double turnAng){
        // speed - sin turn ?
        // turn rad
        // neg turn ang left, pos right, 0 no turn
        /*
        * need width of robot(dist from centre to wheels)?
        * 
        * inner circ/outer
        */
        //turnAng *= -1; // just in case
        System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            // left speed - sin(turn*pi/2)
            //Ls -= Math.sin(turnAng*Math.PI/2);
            Ls = Math.cos(turnAng*Math.PI);
        }
        else if(turnAng > 0){
            // turn Right
            // rihgt speed - sin(-turn*pi/2)
            //Rs -= Math.sin(-turnAng*Math.PI/2);
            Rs = Math.cos(turnAng*Math.PI);
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void pointNShoot(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        arcade(speed, ( ( (currentAng - desiredAng) /180 ) ) );
        // will this work?
    }


  @Override
  public void robotInit() {}

  @Override
  public void robotPeriodic() {}

  @Override
  public void autonomousInit() {}

  @Override
  public void autonomousPeriodic() {
    //System.out.println(camera.getLatestResult());
    PhotonPipelineResult x = camera.getLatestResult();
    PhotonPipelineResult all = camera.getLatestResult();
    List<PhotonTrackedTarget> foundTags = null;
    double range = Double.NEGATIVE_INFINITY;
    
    if(x.hasTargets()){
        foundTags = all.getTargets();
        range = PhotonUtils.calculateDistanceToTargetMeters(Units.inchesToMeters(26.5), Units.inchesToMeters(20), Units.degreesToRadians(0),Units.degreesToRadians(x.getBestTarget().getPitch()));
    
    }
    System.out.println(x);
    System.out.println(range);
    // SmartDashboard.putNumber("x Val", range);
    // double distance = x.getBestTarget().getBestCameraToTarget().getX();
    // double turnedAngle = x.getBestTarget().getBestCameraToTarget().getRotation().getZ();
    // int id = x.getBestTarget().getFiducialId();
    // System.out.println("id " + id);
    // System.out.println(turnedAngle);

    // /* ﻿﻿ The startCompetition() method (or methods called by it) should have handled the exception above. ﻿﻿  */
    // /* This PhotonPipelineResult object has no targets associated with it! Please check hasTargets() before calling this method. For more information, please review the PhotonLib documentation at https://docs.photonvision.org */

    // System.out.println("found tags " + foundTags );

    // SmartDashboard.putNumber("distance", distance);

    // if(distance <= 2){
    //     arcade(0, 0);

    // }
    // else{
    //     arcade(0.4, 0);
    // }
  }

  @Override
  public void teleopInit() {}

  @Override
  public void teleopPeriodic() {}

  @Override
  public void disabledInit() {}

  @Override
  public void disabledPeriodic() {}

  @Override
  public void testInit() {}

  @Override
  public void testPeriodic() {}

  @Override
  public void simulationInit() {}

  @Override
  public void simulationPeriodic() {}
}
