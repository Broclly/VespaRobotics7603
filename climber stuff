// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import javax.crypto.CipherOutputStream;

import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.apriltag.AprilTagDetection;
import edu.wpi.first.apriltag.AprilTagDetector;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFields;
import edu.wpi.first.apriltag.AprilTagPoseEstimator;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.cscore.CvSink;
import edu.wpi.first.cscore.CvSource;
import edu.wpi.first.cscore.UsbCamera;
import edu.wpi.first.math.ComputerVisionUtil;
import edu.wpi.first.math.geometry.CoordinateSystem;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.math.geometry.Translation3d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.networktables.IntegerArrayPublisher;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
    /**
     * This function is run when the robot is first started up and should be used for any
     * initialization code.
     */
    // driving motors
    VictorSPX motorL1 = new VictorSPX(1);
    VictorSPX motorL2 = new VictorSPX(2);
    VictorSPX motorR1 = new VictorSPX(3);
    VictorSPX motorR2 = new VictorSPX(4);
    // shooter motors (id:1 winch, id:3 and 4 shooter, id:2 intake )
    CANSparkMax shooterMotor1 = new CANSparkMax(4, MotorType.kBrushless);
    CANSparkMax shooterMotor2 = new CANSparkMax(3, MotorType.kBrushless);
    // intake motor
    CANSparkMax intakeMotor = new CANSparkMax(2, MotorType.kBrushed);
    // winch motor
    CANSparkMax winchMotor = new CANSparkMax(1, MotorType.kBrushed);

    ADXRS450_Gyro gyro = null;
    Joystick flightStick = new Joystick(0);

    Timer winchTime = new Timer();
    Boolean timeWinchStarted = false;

    Timer autonomousTime = new Timer();
    double autonomousTimePassed = -1;

    double NowAligned = 0;

    int driveMode = 5; // start iarcade v2
    boolean stopWinch = false;

    double[] position = {Double.NaN,Double.NaN,Double.NaN};
    ArrayList<Integer> tagID = new ArrayList<Integer>();
    ArrayList<double[]> tagPos = new ArrayList<double[]>();
    ArrayList<Integer> UpdatedTags = new ArrayList<Integer>();

    int[][] neededTagsPerTeam  = { {/*blue team */ 1, 2, 3}, {/*red team */ 4, 5, 6} };
    int currentTeam = 0; // 0 is blue, 1 is red

    public void tank(double LMS, double RMS){
        // change format for motor controler
        double offset = 0.04 - (LMS/25);
        //offset = 0;
        //System.out.println("tanking");
        LMS = Math.sqrt(LMS);
        RMS = Math.sqrt(RMS);// take smaller power if not good enough
        
        motorL1.set(ControlMode.PercentOutput, LMS - 0*offset);
        motorL2.set(ControlMode.PercentOutput, LMS - 0*offset);

        motorR1.set(ControlMode.PercentOutput, -RMS +0* offset);
        motorR2.set(ControlMode.PercentOutput, -RMS + 0*offset);
        
    }
    public void arcade(double Speed, double turnAng){
        //turnAng *= -1; // just in case
        //System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            Ls = Math.cos(turnAng*Math.PI);
        }
        else if(turnAng > 0){
            // turn Right
            Rs = Math.cos(turnAng*Math.PI);
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void arcadeV2(double Speed, double turnAng){
        // this uses new method to get turning values, linear this time
        //turnAng *= -1; // just in case
        //System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            //Ls = Math.cos(turnAng*Math.PI);
            Ls = 2*turnAng + 1;
        }
        else if(turnAng > 0){
            // turn Right
            //Rs = Math.cos(turnAng*Math.PI);
            Rs = -2*turnAng + 1;
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void pointNShoot(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        double angleDiff = modulo(currentAng - desiredAng, 180);//might need more logic here
        arcade(speed, (angleDiff /-180 ) );
        // will this work?
    }
    public void pointNShootV2(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        arcadeV2(speed, ( (currentAng - desiredAng) /-180 ) );
        // will this work?
    }
    public void pointTHENshoot(double desiredAng, double currentAng, double speed, String version){
        // turn then move
        double angleDiff = -(currentAng - desiredAng);
        if (angleDiff < 5 || angleDiff > -5){
            // within good range I guess
            angleDiff = 0;
        }
        double turnDirection =  Math.signum(angleDiff );

        if (version.equals("V2")){
            arcadeV2( speed, turnDirection);
        }
        else{
            arcade( speed, turnDirection);
        }
    }

    public void shootNote(double speed){
        shooterMotor1.set(speed);
        shooterMotor2.set(speed);
    }
    public void lowerWinch(){
        // need to modify to actually lower winch
        // we could just have user hold till they are high enough?
        //winchMotor.set(-0.8);
        System.out.println("Current");
        System.out.println( winchMotor.getOutputCurrent() );
        //winchMotor.enableVoltageCompensation(winchMotor.getVoltageCompensationNominalVoltage());

        if (timeWinchStarted == false){
            System.out.println("Start timer");
            winchTime.reset();
            timeWinchStarted = true;
        }
        System.out.println("Time");
        System.out.println(winchTime.get());
        
        // I think I can use the output current to see when it's overloaded
        
        double winchCurrentLimit = 2; //19.5; // approx. 20 is where I should stop
        if( (winchMotor.getOutputCurrent() >= winchCurrentLimit && winchTime.get() >= 2.5) || stopWinch == true){
            // motor will stop if current is greater then max after 2.5 seconds or has already stopped
            System.out.println("STOP!!!!");
            winchMotor.set(0);
            winchMotor.stopMotor();
            winchMotor.disable();
            stopWinch = true;
            
        }
        else{
            // motor should be fine, continue to run
            winchMotor.set(-0.8);
        }
        //winchMotor.
        
    }
    public void intakeNote(double speed){
        intakeMotor.set(speed);
    }
    
    public void addToPosDict(int newTagID, double[] newPositions){
        // add updated
        // add pos at correct id
        UpdatedTags.add(newTagID);
        if (tagID.indexOf(newTagID) < 0){
            // id not there add it
            tagID.add(newTagID);
            tagPos.add(null);
        }
        // add new positions at same index of the new tag id
        tagPos.set(tagID.indexOf(newTagID), newPositions);

    }
    public double[] readPosDict(int searchID){
        // try to find id in updated
        // if there get values and return pos
        // else return NaNs
        double[] retPos =  {Double.NaN, Double.NaN, Double.NaN};
        //System.out.println(UpdatedTags.indexOf(searchID));
        if (UpdatedTags.indexOf(searchID) >= 0){
            // the tag was found, get pos
            // find the index in the tag id list, then get value at that index on tag position list
            retPos = tagPos.get(tagID.indexOf(searchID));
        }
        else{
            // tag not found, return the NaNs
        }
        return retPos;
    }

    public boolean alignToTag(double TurnToAng, double speed){
        double angleMargin = Math.PI/12;
        //double angleDiff = -(currentAng - desiredAng);
        boolean IsAligned = false;
        /*
        if ( ( TurnToAng < angleMargin) || TurnToAng > -angleMargin){
            // within good range I guess
            TurnToAng = 0;
            IsAligned = true;
        }
        if (TurnToAng < 0){
            if(TurnToAng ){

            }

        }
        else{
            double turnDirection =  Math.signum(TurnToAng );
            arcade( speed, turnDirection);
        }
        */
        

        if(NowAligned == 0){
            NowAligned = -Math.signum(TurnToAng);
        }

        if (NowAligned < 0){
            // wanted in negative region
            if (TurnToAng <= 0 || TurnToAng >= angleMargin){
                //TurnToAng = 0;
                IsAligned = true;
                //NowAligned = 0;
            }
            else{
                arcade( speed, NowAligned);
            }
        }
        else if(NowAligned > 0){
            // wanted in positive region
            if (TurnToAng >= 0 || TurnToAng <= angleMargin){
                //TurnToAng = 0;
                IsAligned = true;
                //NowAligned = 0;
            }
            else{
                arcade( speed, NowAligned);
            }
        }
        return IsAligned;
    }
  
    public void autonomousFunction(){
        if (autonomousTimePassed == -1){
          autonomousTimePassed = autonomousTime.get();
        }
  
        if(autonomousTime.get() - autonomousTimePassed <= 2){
          // have robot go forward for 2 seconds
        }
        else{
          // need to get angle from april tags,
          // once aligned shoot
          // get gyro angle, sub april tag angle
          double[] aprilPos =  readPosDict(neededTagsPerTeam[currentTeam][0]);
          double aprilAng = Math.toDegrees( Math.atan2(aprilPos[2], aprilPos[0]) );
          double angleToTag = gyro.getAngle() - aprilAng;
          
        }
    }

    public static double modulo(double mod, double of){
        // javas mod operator "%" was being weird so I just made my correct version a function
        mod = mod - of*Math.floor( (mod + of/2 )/of);
        return mod;
    }

    public static double[] getPolarSqr(double xPos, double yPos){
        /*
            * This will convert the coords from a square radius 1, to polar coords radius 1
            * Basicaly gives us the angle and dist from origin when given the coords from joystick (circle-ing the square)
            */
        // to have 0 degrees be forward x and y axis are swaped in atan 2
        double ang = Math.atan2(xPos,yPos);

        double hyp = Math.hypot(xPos, yPos);
        /*
            * to get relative radius reference expected rad for square
            * divide circle rad by sqr rad 
            * (I have a graph on desmos that makes regular polygons from angle, I'm using that)
            * sqr rad = 1/ cos (mod theta + pi/side of 2pi / side ~~a.k.a (theta + pi/side )% 2pi/side~~ - pi/side) ~~side is the number of sides, 4 in this case~~
            * circ rad = sqrt( x^2 + y^2 ) aka the hyp var
            * circ rad/sqr rad ( since sqr rad is 1 over cos, I can just multiply by cos)
            */
        double side = 4;// this var will never need to change
        double modAng = modulo(ang+Math.PI/side, 2*Math.PI/side );
        double squareRad = Math.cos( (modAng - Math.PI/side) );

        // ang is in rad, need it in deg
        ang = Math.toDegrees(ang);

        double[] polarCoords = {hyp*squareRad, ang};
        //System.out.println(polarCoords[0]);
        return polarCoords;
}

    void apriltagVisionThreadProc() {
        var detector = new AprilTagDetector();
        System.out.println("Function running");
        // look for tag16h5, don't correct any error bits
        detector.addFamily("tag36h11", 0);

        // Positions of AprilTags
        /*
        AprilTagFieldLayout aprilTagFieldLayout;
        try {
            aprilTagFieldLayout = AprilTagFieldLayout.loadFromResource(AprilTagFields.k2024Crescendo.m_resourceFile);
        } catch (IOException e) {
        e.printStackTrace();
        aprilTagFieldLayout = null;
        }
        */

        UpdatedTags.clear();

        // Set up Pose Estimator - parameters are for a Microsoft Lifecam HD-3000
        // (https://www.chiefdelphi.com/t/wpilib-apriltagdetector-sample-code/421411/21)
        var poseEstConfig =
            new AprilTagPoseEstimator.Config(
            0.1524, 699.3778103158814, 677.7161226393544, 345.6059345433618, 207.12741326228522);
        var estimator = new AprilTagPoseEstimator(poseEstConfig);

        // Get the UsbCamera from CameraServer
        UsbCamera camera = CameraServer.startAutomaticCapture();
        // Set the resolution
        camera.setResolution(640, 480);

        // Get a CvSink. This will capture Mats from the camera
        CvSink cvSink = CameraServer.getVideo();
        // Setup a CvSource. This will send images back to the Dashboard
        CvSource outputStream = CameraServer.putVideo("Detected", 640, 480);

        // Mats are very memory expensive. Lets reuse these.
        var mat = new Mat();
        var grayMat = new Mat();

        // Instantiate once
        ArrayList<Long> tags = new ArrayList<>();
        var outlineColor = new Scalar(0, 255, 0);
        var crossColor = new Scalar(0, 0, 255);

        // We'll output to NT
        NetworkTable tagsTable = NetworkTableInstance.getDefault().getTable("apriltags");
        IntegerArrayPublisher pubTags = tagsTable.getIntegerArrayTopic("tags").publish();

        // This cannot be 'true'. The program will never exit if it is. This
        // lets the robot stop this thread when restarting robot code or
        // deploying.
        while (!Thread.interrupted()) {
            // Tell the CvSink to grab a frame from the camera and put it
            // in the source mat.  If there is an error notify the output.
            if (cvSink.grabFrame(mat) == 0) {
                // Send the output the error.
                outputStream.notifyError(cvSink.getError());
                // skip the rest of the current iteration
                continue;
            }

            Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_RGB2GRAY);

            AprilTagDetection[] detections = detector.detect(grayMat);

            // have not seen any tags yet
            tags.clear();

            for (AprilTagDetection detection : detections) {

                // april tag layout stuff isnt needed
                /*
                Pose3d tagInFieldFrame; // pose from WPILib resource

                if(aprilTagFieldLayout.getTagPose(detection.getId()).isPresent() && detection.getDecisionMargin() > 50.) // margin < 20 seems bad; margin > 120 are good
                {
                tagInFieldFrame = aprilTagFieldLayout.getTagPose(detection.getId()).get();
                }
                else
                {
                System.out.println("bad id " + detection.getId() + " " + detection.getDecisionMargin());
                continue;
                }
                //
                */

                // remember we saw this tag
                tags.add((long) detection.getId());

                // draw lines around the tag
                for (var i = 0; i <= 3; i++) {
                var j = (i + 1) % 4;
                var pt1 = new Point(detection.getCornerX(i), detection.getCornerY(i));
                var pt2 = new Point(detection.getCornerX(j), detection.getCornerY(j));
                Imgproc.line(mat, pt1, pt2, outlineColor, 2);
                }

                // mark the center of the tag
                var cx = detection.getCenterX();
                var cy = detection.getCenterY();
                var ll = 10;
                Imgproc.line(mat, new Point(cx - ll, cy), new Point(cx + ll, cy), crossColor, 2);
                Imgproc.line(mat, new Point(cx, cy - ll), new Point(cx, cy + ll), crossColor, 2);

                // identify the tag
                Imgproc.putText(
                    mat,
                    Integer.toString(detection.getId()),
                    new Point(cx + ll, cy),
                    Imgproc.FONT_HERSHEY_SIMPLEX,
                    1,
                    crossColor,
                    3);

                // determine pose
                Transform3d pose = estimator.estimate(detection);

                System.out.println("RAW DATA");
                System.out.println("x - should be left to right");
                System.out.println( pose.getX());
                System.out.println("y - up and down (might be inverted)");
                System.out.println( pose.getY());
                System.out.println("z - forwrds and back");
                System.out.println( pose.getZ());

                double[] currentPos = { pose.getX(),  pose.getY(),  pose.getZ()}; // y pos seems to be relative to actual april tag height, so don't use (don't need anyway)
                addToPosDict( detection.getId(), currentPos);
                // These transformations are required for the correct robot pose.
                // They arise from the tag facing the camera thus Pi radians rotated or CCW/CW flipped from the
                // mathematically described pose from the estimator that's what our eyes see. The true rotation
                // has to be used to get the right robot pose.
                pose = new Transform3d(
                    new Translation3d(
                                pose.getX(),
                                pose.getY(),
                                pose.getZ()),
                    new Rotation3d(
                                -pose.getRotation().getX() - Math.PI,
                                -pose.getRotation().getY(),
                                pose.getRotation().getZ() - Math.PI));

                System.out.println("RAW DATA (Corrected?)");
                System.out.println("x - should be left to right");
                System.out.println( pose.getX());
                System.out.println("y - up and down (might be inverted)");
                System.out.println( pose.getY());
                System.out.println("z - forwrds and back");
                System.out.println( pose.getZ());
                this.position[0] = pose.getX();
                this.position[1] = pose.getY();
                this.position[2] = pose.getZ();
                //double[] currentPos = { pose.getX(),  pose.getY(),  pose.getZ()};
                //addToPosDict( detection.getId(), currentPos);


                // OpenCV and WPILib estimator layout of axes is EDN and field WPILib is NWU; need x -> -y , y -> -z , z -> x and same for differential rotations
                // pose = CoordinateSystem.convert(pose, CoordinateSystem.EDN(), CoordinateSystem.NWU());
                // WPILib convert is wrong for transforms as of 2023.4.3 so use this patch for now
            // {
                // corrected convert
                /** 
                var from = CoordinateSystem.EDN();
                var to = CoordinateSystem.NWU();
                pose = new Transform3d(
                        CoordinateSystem.convert(pose.getTranslation(), from, to),
                        CoordinateSystem.convert(new Rotation3d(), to, from)
                            .plus(CoordinateSystem.convert(pose.getRotation(), from, to)));
                // end of corrected convert
                }
                
                var // transform to camera from robot chassis center at floor level
                cameraInRobotFrame = new Transform3d(       
                //                      new Translation3d(0., 0., 0.),// camera at center bottom of robot zeros for test data 
                //                      new Rotation3d(0.0, Units.degreesToRadians(0.), Units.degreesToRadians(0.0))); // camera in line with robot chassis
                                new Translation3d(0.2, 0., 0.0),// camera in front of center of robot and above ground
                                new Rotation3d(0.0, Units.degreesToRadians(0.0), Units.degreesToRadians(0.0))); // camera in line with robot chassis
                                                                                        // y = -30 camera points up; +30 points down; sign is correct but backwards of LL

                var // robot in field is the composite of 3 pieces
                robotInFieldFrame = ComputerVisionUtil.objectToRobotPose(tagInFieldFrame,  pose,  cameraInRobotFrame);
                // end transforms to get the robot pose from this vision tag pose

                // put pose into dashboard
                Rotation3d rot = robotInFieldFrame.getRotation();
                tagsTable
                    .getEntry("pose_" + detection.getId())
                    .setDoubleArray(
                        new double[] {
                        robotInFieldFrame.getX(), robotInFieldFrame.getY(), robotInFieldFrame.getZ(), rot.getX(), rot.getY(), rot.getZ()
                        });
                double x = robotInFieldFrame.getX();
                double y = robotInFieldFrame.getY();
                double z = robotInFieldFrame.getZ();
                */

                int aprilTagId = detection.getId();

                if (aprilTagId == 1 || aprilTagId ==  2 || aprilTagId ==  3 || aprilTagId == 4) {

                //this.position[0] = -(this.position[0] - 15);
                }

                // Pushes the data fetched from an AprilTag to Shuffleboard

                //SmartDashboard.putNumber("Distance", this.position[2]);
                //SmartDashboard.putNumber("Left or Right", this.position[0]);
                //SmartDashboard.putNumber("Camera Angle", this.position[1]);

            }

            // put list of tags onto dashboard
            pubTags.set(tags.stream().mapToLong(Long::longValue).toArray());

            // Give the output stream a new image to display
            outputStream.putFrame(mat);
        }

        pubTags.close();
        detector.close();
    }

    @Override
    public void robotInit() {}

    @Override
    public void robotPeriodic() {}

    @Override
    public void autonomousInit() {}

    @Override
    public void autonomousPeriodic() {
        lowerWinch();
    }

    @Override
    public void teleopInit() {
        gyro = new ADXRS450_Gyro();
    }

    @Override
    public void teleopPeriodic() {
        // check which buttons are pressed, turn on according drive
        if(flightStick.getRawButton(5)){
            // tank drive
            System.out.println("Setting to tank drive");
            driveMode = 1;
        }
        else if(flightStick.getRawButton(6)){
            // arcadeV2
            System.out.println("Setting to arcade drive");
            driveMode = 2;
        }
        else if(flightStick.getRawButton(3)){
            // pointNShootV2
            System.out.println("Setting to point and shoot drive");
            driveMode = 3;
        }
        else if(flightStick.getRawButton(4)){
            // pointTHENshoot
            System.out.println("Setting to point then shoot drive (turns first, then moves)");
            driveMode = 4;
        }
        else if(flightStick.getRawButton(6) && flightStick.getRawButton(2)){
            // arcade
            System.out.println("Setting to arcade drive (original)");
            driveMode = 5;
        }
        else if(flightStick.getRawButton(3) && flightStick.getRawButton(2)){
            // pointNShoot
            System.out.println("Setting to point and shoot drive (original)");
            driveMode = 6;
        }
        
        // reset gyro
        if(flightStick.getRawButton(9)){
            gyro = new ADXRS450_Gyro();
        }

        // drive in selected mode
        double leftToRightValue = flightStick.getRawAxis(0);
        double forwardBackValue = flightStick.getRawAxis(1);
        if(driveMode == 1){
            // tank drive
            // to rotate to make nicer
            //double[] joyCoords = getPolarSqr(forwardBackValue, - leftToRightValue);


            tank(leftToRightValue, forwardBackValue );
        }
        else if(driveMode == 2){
            // arcadeV2
            arcadeV2(-forwardBackValue, -leftToRightValue);
        }
        else if(driveMode == 3){
            // pointNShootV2
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointNShootV2(polarJoy[1], gyroAngle, polarJoy[0]);
        }
        else if(driveMode == 4){
            // pointTHENshoot
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointTHENshoot(polarJoy[1], gyroAngle, polarJoy[0], "V2");
        }
        else if(driveMode == 5){
            // arcade
            arcade(forwardBackValue, leftToRightValue);
        }
        else if(driveMode == 6){
            // pointNShoot
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointNShoot(polarJoy[1], gyroAngle, polarJoy[0]);
        }
    
        // shooter/intake
        if (flightStick.getRawButton(1)){
            // while being pressed run shooter
            System.out.println("SHOOT");
            shootNote(1);
        }

        if (flightStick.getRawButton(7)){
            // while being pressed run intake
            intakeNote(0.9);
        }
    }

    @Override
    public void disabledInit() {}

    @Override
    public void disabledPeriodic() {}

    @Override
    public void testInit() {}

    @Override
    public void testPeriodic() {}

    @Override
    public void simulationInit() {}

    @Override
    public void simulationPeriodic() {}
}
