package frc.robot;

import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.TimedRobot;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkLowLevel.MotorType;

import java.util.ResourceBundle.Control;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;

import edu.wpi.first.wpilibj.Timer;

/**
 * This is a demo program showing the use of the DifferentialDrive class, specifically it contains
 * the code necessary to operate a robot with tank drive.
 */
public class Robot extends TimedRobot {

  private VictorSPX driveLeftSpark = new VictorSPX(1);
  private VictorSPX driveRightSpark = new VictorSPX(3);
  private VictorSPX driveLeftVictor = new VictorSPX(2);
  private VictorSPX driveRightVictor = new VictorSPX(4);
  private Joystick newJoystick = new Joystick(0);
  CANSparkMax armMotor = new CANSparkMax(1, MotorType.kBrushless);
  CANSparkMax shooterMotorBase = new CANSparkMax(2, MotorType.kBrushless);
  CANSparkMax shooterMotor1 = new CANSparkMax(3, MotorType.kBrushless);
  CANSparkMax shooterMotor2 = new CANSparkMax(4, MotorType.kBrushless);
  // Add a variable to track whether the turn button was pressed in the previous iteration
  private boolean previousButtonState = false;

  Timer autoTimer = new Timer();

  // Timer to control the duration of the turn
  private double turnStartTime = 0.0;
  private double turnDuration = 2.0; // Adjust the duration as needed
  private double autonomousStartTime;
  @Override
  public void robotInit() {
    CameraServer.startAutomaticCapture();

    System.out.println();
  
    // We need to invert one side of the drivetrain so that positive voltages
    // result in both sides moving forward. Depending on how your robot's
    // gearbox is constructed, you might have to invert the left side instead.
  }

  @Override
  public void teleopPeriodic() {
    double x_ampl = newJoystick.getRawAxis(1);
    double y_ampl = newJoystick.getRawAxis(0);
    double leftSpeed = (-x_ampl + y_ampl);
    double rightSpeed = (y_ampl + x_ampl);
    
    if (newJoystick.getRawButton(12)){
      armMotor.set(1);
    }else if(newJoystick.getRawButton(11)){
      armMotor.set(-1);
    }else{
      armMotor.set(0);
    }

    if (newJoystick.getRawButton(1)){
      shooterMotor1.set(-5);
      shooterMotor2.set(-5);
    }
    else if (newJoystick.getRawButton(2)){
      shooterMotor1.set(5);
      shooterMotor2.set(5);
    }  
    else if(newJoystick.getRawButton(6)){
      shooterMotor2.set(-5);
    }
    else{
      shooterMotor1.set(0);
      shooterMotor2.set(0);
    }


    if (newJoystick.getRawButton(5)){
      shooterMotorBase.set(1);
    }
    else if(newJoystick.getRawButton(3)){
      shooterMotorBase.set(-1);
    }
    else{
      shooterMotorBase.set(0);
    }

    if (leftSpeed > 1) {
      leftSpeed = leftSpeed / 3;
    }

    if (rightSpeed > 1) {
      rightSpeed = rightSpeed / 3;
    }

    //System.out.println("Left Speed: " + leftSpeed);
    //System.out.println("Right Speed: " + rightSpeed);

    // Update the previous button state for the next iteration

    driveLeftSpark.set(ControlMode.PercentOutput, leftSpeed);
    driveLeftVictor.set(ControlMode.PercentOutput, leftSpeed);
    driveRightVictor.set(ControlMode.PercentOutput, rightSpeed);
    driveRightSpark.set(ControlMode.PercentOutput, rightSpeed);
  }

  @Override
  public void autonomousInit() {
    // Add any initialization code for autonomous mode here.
     autonomousStartTime = Timer.getFPGATimestamp();
     autoTimer.reset();
     autoTimer.start();

  }

  @Override
  public void autonomousPeriodic() {
    double timeElapsed = Timer.getFPGATimestamp() - autonomousStartTime;
    timeElapsed = autoTimer.get();
    double jerk1 = 0.2;
    double jerk2 = jerk1 + 0.2;
    double p1Time = jerk2 + 4;// rev top motor
    double p2Time = p1Time + 1; // shoot note
    double p3Time = p2Time + 3;// backup
    double jerkSpeed = 0.8;
    //double p4Time = 3;// backup?
    if (timeElapsed < jerk1 ){

        //driveLeftSpark.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveLeftVictor.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveRightVictor.set(ControlMode.PercentOutput, jerkSpeed);
        //driveRightSpark.set(ControlMode.PercentOutput, jerkSpeed);
  
    } else if(timeElapsed <jerk2){
        //driveLeftSpark.set(ControlMode.PercentOutput, jerkSpeed);
        //driveLeftVictor.set(ControlMode.PercentOutput, jerkSpeed);
        //driveRightVictor.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveRightSpark.set(ControlMode.PercentOutput, -jerkSpeed);
    }
    else if (timeElapsed < p1Time ){
        //shooterMotor2.set(-5);
        //driveLeftSpark.set(ControlMode.PercentOutput, 0);
        //driveLeftVictor.set(ControlMode.PercentOutput, 0);
        //driveRightVictor.set(ControlMode.PercentOutput, 0);
        //driveRightSpark.set(ControlMode.PercentOutput, 0);

    } else if(timeElapsed < p2Time){
      //shooterMotor1.set(-5);
      //shooterMotor2.set(-5);
    }else if(timeElapsed < p3Time){   
      driveLeftSpark.set(ControlMode.PercentOutput, -0.5);
      driveLeftVictor.set(ControlMode.PercentOutput, -0.5);
      driveRightVictor.set(ControlMode.PercentOutput, 0.6);
      driveRightSpark.set(ControlMode.PercentOutput, 0.6);
    } else{
      driveLeftSpark.set(ControlMode.PercentOutput, 0);
      driveLeftVictor.set(ControlMode.PercentOutput, 0);
      driveRightVictor.set(ControlMode.PercentOutput, 0);
      driveRightSpark.set(ControlMode.PercentOutput, 0);
      shooterMotor1.set(0);
      shooterMotor2.set(0);
    }
  }
}
