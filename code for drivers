// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
    /**
     * This function is run when the robot is first started up and should be used for any
     * initialization code.
     */
    // driving motors
    VictorSPX motorL1 = new VictorSPX(1);
    VictorSPX motorL2 = new VictorSPX(2);
    VictorSPX motorR1 = new VictorSPX(3);
    VictorSPX motorR2 = new VictorSPX(4);
    // shooter motors (id:1 winch, id:3 and 4 shooter, id:2 intake )
    CANSparkMax shooterMotor1 = new CANSparkMax(4, MotorType.kBrushed);
    CANSparkMax shooterMotor2 = new CANSparkMax(3, MotorType.kBrushed);
    // intake motor
    CANSparkMax intakeMotor = new CANSparkMax(2, MotorType.kBrushed);
    // winch motor
    CANSparkMax winchMotor = new CANSparkMax(1, MotorType.kBrushed);

    ADXRS450_Gyro gyro = null;
    Joystick flightStick = new Joystick(0);

    Timer winchTime = new Timer();
    Boolean timeWinchStarted = false;

    int driveMode = 4; // start in point then shoot
    boolean stopWinch = false;

    public void tank(double LMS, double RMS){
        // change format for motor controler
        double offset = 0.04 - (LMS/25);
        //offset = 0;
        //System.out.println("tanking");
        LMS = Math.sqrt(LMS);
        RMS = Math.sqrt(RMS);// take smaller power if not good enough
        
        motorL1.set(ControlMode.PercentOutput, LMS - 0*offset);
        motorL2.set(ControlMode.PercentOutput, LMS - 0*offset);

        motorR1.set(ControlMode.PercentOutput, -RMS +0* offset);
        motorR2.set(ControlMode.PercentOutput, -RMS + 0*offset);
        
    }
    public void arcade(double Speed, double turnAng){
        //turnAng *= -1; // just in case
        //System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            Ls = Math.cos(turnAng*Math.PI);
        }
        else if(turnAng > 0){
            // turn Right
            Rs = Math.cos(turnAng*Math.PI);
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void arcadeV2(double Speed, double turnAng){
        // this uses new method to get turning values, linear this time
        //turnAng *= -1; // just in case
        //System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            //Ls = Math.cos(turnAng*Math.PI);
            Ls = 2*turnAng + 1;
        }
        else if(turnAng > 0){
            // turn Right
            //Rs = Math.cos(turnAng*Math.PI);
            Rs = -2*turnAng + 1;
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void pointNShoot(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        double angleDiff = modulo(currentAng - desiredAng, 180);//might need more logic here
        arcade(speed, (angleDiff /-180 ) );
        // will this work?
    }
    public void pointNShootV2(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        arcadeV2(speed, ( (currentAng - desiredAng) /-180 ) );
        // will this work?
    }
    public void pointTHENshoot(double desiredAng, double currentAng, double speed, String version){
        // turn then move
        double angleDiff = -(currentAng - desiredAng);
        if (angleDiff < 5 || angleDiff > -5){
            // within good range I guess
            angleDiff = 0;
        }
        double turnDirection =  Math.signum(angleDiff );

        if (version.equals("V2")){
            arcadeV2( speed, turnDirection);
        }
        else{
            arcade( speed, turnDirection);
        }
    }

    public void shootNote(double speed){
        shooterMotor1.set(speed);
        shooterMotor2.set(speed);
    }
    public void lowerWinch(){
        // need to modify to actually lower winch
        // we could just have user hold till they are high enough?
        //winchMotor.set(-0.8);
        System.out.println("Current");
        System.out.println( winchMotor.getOutputCurrent() );

        if (!timeWinchStarted){
            winchTime.reset();
            timeWinchStarted = true;
        }
        
        // I think I can use the output current to see when it's overloaded
        
        double winchCurrentLimit = 19.5;
        if( (winchMotor.getOutputCurrent() >= winchCurrentLimit && winchTime.get() >= 2.5) || stopWinch){
            // motor will stop if current is greater then max after 2.5 seconds or has already stopped
            winchMotor.set(0);
            winchMotor.stopMotor();
            winchMotor.disable();
            stopWinch = true;
            
        }
        else{
            // motor should be fine, continue to run
            winchMotor.set(-0.8);
        }
        //winchMotor.
        
    }
    public void intakeNote(double speed){
        intakeMotor.set(speed);
    }
    
    public static double modulo(double mod, double of){
        // javas mod operator "%" was being weird so I just made my correct version a function
        mod = mod - of*Math.floor( (mod + of/2 )/of);
        return mod;
    }

    public static double[] getPolarSqr(double xPos, double yPos){
        /*
            * This will convert the coords from a square radius 1, to polar coords radius 1
            * Basicaly gives us the angle and dist from origin when given the coords from joystick (circle-ing the square)
            */
        // to have 0 degrees be forward x and y axis are swaped in atan 2
        double ang = Math.atan2(xPos,yPos);

        double hyp = Math.hypot(xPos, yPos);
        /*
            * to get relative radius reference expected rad for square
            * divide circle rad by sqr rad 
            * (I have a graph on desmos that makes regular polygons from angle, I'm using that)
            * sqr rad = 1/ cos (mod theta + pi/side of 2pi / side ~~a.k.a (theta + pi/side )% 2pi/side~~ - pi/side) ~~side is the number of sides, 4 in this case~~
            * circ rad = sqrt( x^2 + y^2 ) aka the hyp var
            * circ rad/sqr rad ( since sqr rad is 1 over cos, I can just multiply by cos)
            */
        double side = 4;// this var will never need to change
        double modAng = modulo(ang+Math.PI/side, 2*Math.PI/side );
        double squareRad = Math.cos( (modAng - Math.PI/side) );

        // ang is in rad, need it in deg
        ang = Math.toDegrees(ang);

        double[] polarCoords = {hyp*squareRad, ang};
        //System.out.println(polarCoords[0]);
        return polarCoords;
}


    @Override
    public void robotInit() {}

    @Override
    public void robotPeriodic() {}

    @Override
    public void autonomousInit() {}

    @Override
    public void autonomousPeriodic() {
        lowerWinch();
    }

    @Override
    public void teleopInit() {
        gyro = new ADXRS450_Gyro();
    }

    @Override
    public void teleopPeriodic() {
        // check which buttons are pressed, turn on according drive
        if(flightStick.getRawButton(5)){
            // tank drive
            System.out.println("Setting to tank drive");
            driveMode = 1;
        }
        else if(flightStick.getRawButton(6)){
            // arcadeV2
            System.out.println("Setting to arcade drive");
            driveMode = 2;
        }
        else if(flightStick.getRawButton(3)){
            // pointNShootV2
            System.out.println("Setting to point and shoot drive");
            driveMode = 3;
        }
        else if(flightStick.getRawButton(4)){
            // pointTHENshoot
            System.out.println("Setting to point then shoot drive (turns first, then moves)");
            driveMode = 4;
        }
        else if(flightStick.getRawButton(6) && flightStick.getRawButton(2)){
            // arcade
            System.out.println("Setting to arcade drive (original)");
            driveMode = 5;
        }
        else if(flightStick.getRawButton(3) && flightStick.getRawButton(2)){
            // pointNShoot
            System.out.println("Setting to point and shoot drive (original)");
            driveMode = 6;
        }
        
        // reset gyro
        if(flightStick.getRawButton(9)){
            gyro = new ADXRS450_Gyro();
        }

        // drive in selected mode
        double leftToRightValue = flightStick.getRawAxis(1);
        double forwardBackValue = flightStick.getRawAxis(0);
        if(driveMode == 1){
            // tank drive
            // to rotate to make nicer
            //double[] joyCoords = getPolarSqr(forwardBackValue, - leftToRightValue);


            tank(leftToRightValue, forwardBackValue );
        }
        else if(driveMode == 2){
            // arcadeV2
            arcadeV2(forwardBackValue, leftToRightValue);
        }
        else if(driveMode == 3){
            // pointNShootV2
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointNShootV2(polarJoy[1], gyroAngle, polarJoy[0]);
        }
        else if(driveMode == 4){
            // pointTHENshoot
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointTHENshoot(polarJoy[1], gyroAngle, polarJoy[0], "V2");
        }
        else if(driveMode == 5){
            // arcade
            arcade(forwardBackValue, leftToRightValue);
        }
        else if(driveMode == 6){
            // pointNShoot
            double gyroAngle = gyro.getAngle();
            gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
            double[] polarJoy = getPolarSqr(forwardBackValue, - leftToRightValue);
            pointNShoot(polarJoy[1], gyroAngle, polarJoy[0]);
        }
    
        // shooter/intake
        if (flightStick.getRawButton(0)){
            // while being pressed run shooter
            shootNote(0.9);
        }

        if (flightStick.getRawButton(7)){
            // while being pressed run intake
            intakeNote(0.9);
        }
    }

    @Override
    public void disabledInit() {}

    @Override
    public void disabledPeriodic() {}

    @Override
    public void testInit() {}

    @Override
    public void testPeriodic() {}

    @Override
    public void simulationInit() {}

    @Override
    public void simulationPeriodic() {}
}
