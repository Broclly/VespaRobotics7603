// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.Timer;

// motors
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;

// controls (joystick)
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.button.JoystickButton;
import edu.wpi.first.wpilibj2.command.button.Trigger;

// used for april tags
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;

import javax.crypto.CipherOutputStream;

import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import edu.wpi.first.apriltag.AprilTagDetection;
import edu.wpi.first.apriltag.AprilTagDetector;
import edu.wpi.first.apriltag.AprilTagFieldLayout;
import edu.wpi.first.apriltag.AprilTagFields;
import edu.wpi.first.apriltag.AprilTagPoseEstimator;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.cscore.CvSink;
import edu.wpi.first.cscore.CvSource;
import edu.wpi.first.cscore.UsbCamera;
import edu.wpi.first.math.ComputerVisionUtil;
import edu.wpi.first.math.geometry.CoordinateSystem;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Transform3d;
import edu.wpi.first.math.geometry.Translation3d;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.networktables.IntegerArrayPublisher;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;

// gyro and smart dash
//import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
//import edu.wpi.first.cameraserver.*;
//import edu.wpi.first.wpilibj.Joystick;
//import edu.wpi.first.cameraserver.*;


/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
    /**
     * This function is run when the robot is first started up and should be used for any
     * initialization code.
     */
    VictorSPX motorL2 = new VictorSPX(7);
    VictorSPX motorR1 = new VictorSPX(5);
    VictorSPX motorR2 = new VictorSPX(6);
    VictorSPX motorL1 = new VictorSPX(10);

    //VictorSPX ShooterMotor = new VictorSPX(5);

    // needed shooter constants
    double angle = Math.toRadians(50);
    double grav = 9.8;
    double shooterD = 0; // distance offset of shooter from camera (how far forward is the exit of the shooter relative to the camera)
    double shooterH = 0; // height offset of shooter from camera  (how much higher is the exit of the shooter relative to the camera)
    double targetATHeight = 1; // height of target in m, ( if there are different target more logic can be added later)

    double launchTestDist = 10; // get from testing, measure in meters
    double maxVel = Math.sqrt( (grav*launchTestDist) / 2*(Math.tan(angle) + shooterH) ) / Math.cos(angle);
    //double maxRange = ( Math.tan(angle)*2* Math.pow(maxVel * Math.cos(angle) , 2) ) / 2*grav;
    double maxRange = 2;
    //~~~~~~~~~~~~~~~~~~~~~~~~~
    
    ADXRS450_Gyro gyro = new ADXRS450_Gyro();
    Joystick flightStick = new Joystick(0);
    
    Trigger aprilButton = new JoystickButton(flightStick, 0);

    double[] position = {Double.NaN,Double.NaN,Double.NaN};
    ArrayList<Integer> tagID = new ArrayList<Integer>();
    ArrayList<double[]> tagPos = new ArrayList<double[]>();
    ArrayList<Integer> UpdatedTags = new ArrayList<Integer>();
    //ArrayList<double[][]> allPositions = new ArrayList<double[][]>(  ) ; // he he :} list list
    // each list will contian a list of positions and tag id at end? 8} OR TRIPLE LIST!!!!!
    /* add item to list like shown below first array contains positions, second contains id
    double[][] tempList = {{1.0, 2.0, 3.0}, {5.0}};
    allPositions.add(tempList); */
    /* retrive from list like below
        System.out.println(allPositions.get(0));
        System.out.println(allPositions.get(0)[0]);
        System.out.println(allPositions.get(0)[1][0]); // this will give you the specific info
     */
    //boolean toggle = true;
    int[][] neededTagsPerTeam  = { {/*blue team */ 1, 2, 3}, {/*red team */ 4, 5, 6} };
    int currentTeam = 0; // 0 is blue, 1 is red

    Timer autonomousTime = new Timer();
    double autonomousTimePassed = -1;

    double alignToAngle = 0;

    Timer autoTimer = new Timer();
    int autoStage = 2;
    boolean alignedRun = false;


    //driveTrain drive = new driveTrain(motorL1, motorL2, motorR1, motorR2);

    public void tank(double LMS, double RMS){
        // change format for motor controler
        double offset = 0.04 - (LMS/25);
        //System.out.println("tanking");
        motorL1.set(ControlMode.PercentOutput, LMS - offset);
        motorL2.set(ControlMode.PercentOutput, LMS - offset);

        motorR1.set(ControlMode.PercentOutput, -RMS);
        motorR2.set(ControlMode.PercentOutput, -RMS);
    }
    public void arcade(double Speed, double turnAng){
        // speed - sin turn ?
        // turn rad
        // neg turn ang left, pos right, 0 no turn
        /*
        * need width of robot(dist from centre to wheels)?
        * 
        * inner circ/outer
        */
        //turnAng *= -1; // just in case
        System.out.println(turnAng);
        double Ls = 1;
        double Rs = 1;
        if (turnAng < 0){
            //turn left
            // left speed - sin(turn*pi/2)
            //Ls -= Math.sin(turnAng*Math.PI/2);
            Ls = Math.cos(turnAng*Math.PI);
        }
        else if(turnAng > 0){
            // turn Right
            // rihgt speed - sin(-turn*pi/2)
            //Rs -= Math.sin(-turnAng*Math.PI/2);
            Rs = Math.cos(turnAng*Math.PI);
        }
        else{
            // dont turn
        }
        tank(Ls*Speed, Rs*Speed);
    }
    public void pointNShoot(double desiredAng, double currentAng, double speed){
        // curAng - desAng?
        arcade(speed, ( ( (currentAng - desiredAng) /180 ) ) );
        // will this work?
    }

    public void addToPosDict(int newTagID, double[] newPositions){
        // add updated
        // add pos at correct id
        UpdatedTags.add(newTagID);
        if (tagID.indexOf(newTagID) < 0){
            // id not there add it
            tagID.add(newTagID);
            tagPos.add(null);
        }
        // add new positions at same index of the new tag id
        tagPos.set(tagID.indexOf(newTagID), newPositions);

    }
    public double[] readPosDict(int searchID){
        // try to find id in updated
        // if there get values and return pos
        // else return NaNs
        double[] retPos =  {Double.NaN, Double.NaN, Double.NaN};
        //System.out.println(UpdatedTags.indexOf(searchID));
        if (UpdatedTags.indexOf(searchID) >= 0){
            // the tag was found, get pos
            // find the index in the tag id list, then get value at that index on tag position list
            retPos = tagPos.get(tagID.indexOf(searchID));
        }
        else{
            // tag not found, return the NaNs
        }
        return retPos;
    }

    public static double modulo(double mod, double of){
        // javas mod operator "%" was being weird so I just made my correct version a function
        mod = mod - of*Math.floor( (mod + of/2 )/of);
        return mod;
    }

    public static double[] getPolarSqr(double xPos, double yPos){
        /*
            * This will convert the coords from a square radius 1, to polar coords radius 1
            * Basicaly gives us the angle and dist from origin when given the coords from joystick (circle-ing the square)
            */
        // to have 0 degrees be forward x and y axis are swaped in atan 2
        double ang = Math.atan2(xPos,yPos);
        /*if (ang < 0 && false){
                        ang += 2*Math.PI;
                        // was to have vary from 0 to 2pi instead of -pi to pi, but I think - pi to pi is best
        }*/
        //System.out.println("angle");
        //System.out.println(ang);
        double hyp = Math.hypot(xPos, yPos);
        /*
            * to get relative radius reference expected rad for square
            * divide circle rad by sqr rad 
            * (I have a graph on desmos that makes regular polygons from angle, I'm using that)
            * sqr rad = 1/ cos (mod theta + pi/side of 2pi / side ~~a.k.a (theta + pi/side )% 2pi/side~~ - pi/side) ~~side is the number of sides, 4 in this case~~
            * circ rad = sqrt( x^2 + y^2 ) aka the hyp var
            * circ rad/sqr rad ( since sqr rad is 1 over cos, I can just multiply by cos)
            */
        double side = 4;// this var will never need to change
        double modAng = modulo(ang+Math.PI/side, 2*Math.PI/side );
        //double modulusThing = (ang+Math.PI/side) - (2*Math.PI/side)*Math.floor( (ang+Math.PI/side) / (2*Math.PI/side) ); // mod function is x - yFloor(x/y), where x is first num and y is second ( this is the same as x mod y or x % y or mod x of y or mod(x,y) )
        double squareRad = Math.cos( (modAng - Math.PI/side) );
        /*
        System.out.println("Mod?");
        System.out.println( (ang+Math.PI/side) % (2*Math.PI/side));
        System.out.println("This should be squre rad");
        System.out.println(1/squareRad);
        */

        // ang is in rad, need it in deg
        ang = Math.toDegrees(ang);

        double[] polarCoords = {hyp*squareRad, ang};
        //System.out.println(polarCoords[0]);
        return polarCoords;
}

    public double getVel( double dist, double height){
        /*
         * need angle - const, distance away, height, g - const, h shooter dist, v shooter dist
         * sqrt(-(g*d^2)/ 2*(height - tan(ang)*d))/cos(angle)
         * angle in rad, dists in m
         */
        dist -= shooterD;
        height -= shooterH;
        // check if within half the max range
        double vel = ( Math.sqrt( -( grav*(dist*dist) ) /(2*( height - Math.tan(angle)*dist )) ) ) / Math.cos(angle);
        // where could this return NaN and why?
        // NaN if radical is neg, when -grav*dist^2 / (2*( height - tan(angle)*dist ) ) < 0
            // might be different reasons for NaN dependant on where the neg accured (numerator or denominator)
            // need to check intervals of -grav*dist^2
                // -grav*dist^2 = 0, dist^2 = 0, dist = 0
                // (-inf, 0) -> neg, [0] -> 0, (0, inf) -> neg
            // need to check intervals of 2*( height - tan(angle)*dist )
                // 2*( height - tan(angle)*dist ) = 0,  height - tan(angle)*dist = 0, - tan(angle)*dist = - height, tan(angle)*dist = height or dist = height / tan(angle)
                // how to control for 2 vars? by ignoring one? I only need to know when neg and pos. BY NOTING THE RELATIONS BETWEEN THEM!?!!
                // neg when dist or height is neg (should never happen), pos when both are pos or neg, 0 when tan(angle)*dist = height
                // there would also be error when height > tan angle dist
                // neg when height - tan(angle)*dist < 0, 0 when height - tan(angle)*dist = 0, pos when height - tan(angle)*dist > 0
                // (-inf, height - tan(angle)*dist = 0 ) -> neg, [height - tan(angle)*dist = 0] -> 0, ( height - tan(angle)*dist = 0, inf ) -> pos
            // together, neg when height - tan(angle)*dist > 0, 0 when dist = 0, pos when height - tan(angle)*dist < 0, NaN when height - tan(angle)*dist = 0
            // meaning radical is negative/NaN ( and thus not real enough :C <-- very sad ) when height - tan(angle)*dist >= 0
            // when height - tan(angle)*dist >= 0, means that either dist needs to be larger or height needs to be smaller (either way dist is smaller than height)* 
                // *{ applies to the absolute value of dist and height but we don't need to worry cause there will be no negative dist or height }
        // NaN if denominator o' radical is 0 ( accomadated above)
        // NaN if tan angle is Nan, when angle is 90 (should never happen)
        // !!!!! In conclusion if vel is NaN that could only be because height - tan(angle)*dist >= 0, and the only solution is to make dist larger or height smaller
            // we can't change height so we would have to move backwards no matter what.
        return vel;
    }

    public void autoAim(double horizontal, double distance, double vertical){
        /*
         * need april tag positions, can take all 3 or do math outside
         * maybe angle to april tag? then I can turn from here
         * Should I move closer myself?
         * Should I tell user if I can't?
         * 
         * get angle to april tag, then turn to align
         * get closer till it's in range (how to find range?, get in getVel)
         * calc velocity, get speed and shoot
         */
        // max velocity can be calced by mesuring launch dist (in m) at max vel, sqrt( (9.8*max)/2*tan(angle)) / cos(angle)
        // range can be calced with ( tan angle * 2 * (max volcity*cos angle)^2)/ 9.8

        // dividing here, don't divide above
        //maxRange /= 2; nevermind
        double[] neededPos = readPosDict(neededTagsPerTeam[currentTeam][0]);
        System.out.println("getting pos for " + neededTagsPerTeam[currentTeam][0]);
        horizontal = neededPos[0];
        distance = neededPos[2];
        vertical = neededPos[1];
        // max vel and max range are constants, could be repalced with constant instead of math, however we would need to be very accurate
        double APAngle = Math.atan2(horizontal, distance);
        System.out.println("Angle");
        System.out.println(APAngle);
        
        if ( APAngle < Math.PI/12 && APAngle > -Math.PI/12){
            // checks if shooter is aligned (within acceptable range), should probably use angles for better accuracy
            
            double dist = Math.sqrt( distance*distance + horizontal*horizontal);
            System.out.println("DISTANCE");
            System.out.println(dist);
            
            if (dist <= maxRange){
                // within range, try shooting
                double neededVel = getVel(dist, targetATHeight)/maxVel;
                if (neededVel <= 1){
                    // motor can hit target
                    // shoot at speed of needed vel
                    System.out.println("SHOOT");
                    System.out.println(neededVel);
                    //ShooterMotor.set(ControlMode.PercentOutput, neededVel);
                }
                else{
                    // get closer? or get further away? should I make logic to find where it went wrong?
                    //System.out.println("In range but can't shoot? target too high? Too close?");

                    // delt with NaN logic in get vel, so when needed vel is NaN - move back
                    // when less than 1, move back* ( there is a point were moving forward is best but that is when dist is past maximum, already delt with in max range)
                    arcade(-0.15, 0);
                }
            }
            else{
                // get closer
                arcade(0.15, 0);
            }
        }
        else{
            if (Double.isNaN(horizontal) || Double.isNaN(distance) || Double.isNaN(vertical)){
                // april tag not found, turn till found
                System.out.println("Not found, turn v5");
                arcade(0.3, 1);
            }
            else{
                // turn ( turns at speed 0.3 - can adjust later, turn on the spot towords tag)
                arcade(0.2, Math.signum(APAngle));
            }
        }
    }

    public void pointTHENshoot(double desiredAng, double currentAng, double speed){
      // turn then move
      double angleDiff = -(currentAng - desiredAng);
      if (angleDiff < 5 || angleDiff > -5){
          // within good range I guess
          angleDiff = 0;
      }
      double turnDirection =  Math.signum(angleDiff );

      arcade( speed, turnDirection);
      
  }

    public boolean alignToTag(double TurnToAng, double speed){
      double angleMargin = Math.PI/12;
      //double angleDiff = -(currentAng - desiredAng);
      if (TurnToAng < angleMargin || TurnToAng > -angleMargin){
          // within good range I guess
          TurnToAng = 0;
      }
      double turnDirection =  Math.signum(TurnToAng );
      boolean IsAligned = false;
      if(turnDirection == 0){ IsAligned = true;}
      arcade( speed, turnDirection);
      return IsAligned;
    }

    public boolean alignToAngleFunc(double currentAngle){
      // turn till angle in good range
      // wanted - current, gives diff and direction in sign
      double angleDiff = alignToAngle - currentAngle;
      System.out.println("Current angle: " + currentAngle);
      System.out.println("Align to angle: " + alignToAngle);
      System.out.println("angle diff: " + angleDiff);

      boolean returnMe = false;

      if( alignToAngle > 0 ){
        if( angleDiff <= 0 ){
          // stop moving
          System.out.println("STOP turning right 1");
          arcade(0, 0);
          returnMe = true;

        }
        else{
          arcade(0.25,1);
        }

      }
      else if(alignToAngle < 0){
          if( angleDiff >= 0 ){
            // stop moving
            System.out.println("STOP turning left -1");
            arcade(0, 0);
            returnMe = true;
          }
          else{
            arcade(0.25, -1);
          }
      }
      else{
        // aligned stop
        returnMe = true;
      }
      return returnMe;
      
    }
    public void alignInit(double wantedAng){
      if(alignedRun == false){
        gyro.reset();
        //System.out.println("Id " + neededTagsPerTeam[currentTeam][0]);
        //double[] aprilPos = readPosDict(neededTagsPerTeam[currentTeam][0]);
        //double angToPos = Math.atan2(aprilPos[0] , aprilPos[2]);
        //System.out.println(angToPos);
        //alignToAngle = angToPos - gyro.getAngle();
        alignToAngle = wantedAng - 0;
        //autoTimer.reset();
        alignedRun = true;
      }
    }

    public void autonomousFunction(){
      if (autonomousTimePassed == -1){
        autonomousTimePassed = autonomousTime.get();
      }

      if(autonomousTime.get() - autonomousTimePassed <= 2){
        // have robot go forward for 2 seconds
      }
      else if (alignToTag(1, 0.2)){
        // need to get angle from april tags,
        // once aligned shoot
        
      }
    }

    void apriltagVisionThreadProc() {
      var detector = new AprilTagDetector();
      System.out.println("Function running");
      // look for tag16h5, don't correct any error bits
      detector.addFamily("tag36h11", 0);
  
      // Positions of AprilTags
      AprilTagFieldLayout aprilTagFieldLayout;
      try {
          aprilTagFieldLayout = AprilTagFieldLayout.loadFromResource(AprilTagFields.k2024Crescendo.m_resourceFile);
      } catch (IOException e) {
        e.printStackTrace();
        aprilTagFieldLayout = null;
      }

      UpdatedTags.clear();
  
      // Set up Pose Estimator - parameters are for a Microsoft Lifecam HD-3000
      // (https://www.chiefdelphi.com/t/wpilib-apriltagdetector-sample-code/421411/21)
      var poseEstConfig =
          new AprilTagPoseEstimator.Config(
            0.1524, 699.3778103158814, 677.7161226393544, 345.6059345433618, 207.12741326228522);
      var estimator = new AprilTagPoseEstimator(poseEstConfig);
  
      // Get the UsbCamera from CameraServer
      UsbCamera camera = CameraServer.startAutomaticCapture();
      // Set the resolution
      camera.setResolution(640, 480);
  
      // Get a CvSink. This will capture Mats from the camera
      CvSink cvSink = CameraServer.getVideo();
      // Setup a CvSource. This will send images back to the Dashboard
      CvSource outputStream = CameraServer.putVideo("Detected", 640, 480);
  
      // Mats are very memory expensive. Lets reuse these.
      var mat = new Mat();
      var grayMat = new Mat();
  
      // Instantiate once
      ArrayList<Long> tags = new ArrayList<>();
      var outlineColor = new Scalar(0, 255, 0);
      var crossColor = new Scalar(0, 0, 255);
  
      // We'll output to NT
      NetworkTable tagsTable = NetworkTableInstance.getDefault().getTable("apriltags");
      IntegerArrayPublisher pubTags = tagsTable.getIntegerArrayTopic("tags").publish();
  
      // This cannot be 'true'. The program will never exit if it is. This
      // lets the robot stop this thread when restarting robot code or
      // deploying.
      while (!Thread.interrupted()) {
        // Tell the CvSink to grab a frame from the camera and put it
        // in the source mat.  If there is an error notify the output.
        if (cvSink.grabFrame(mat) == 0) {
          // Send the output the error.
          outputStream.notifyError(cvSink.getError());
          // skip the rest of the current iteration
          continue;
        }
  
        Imgproc.cvtColor(mat, grayMat, Imgproc.COLOR_RGB2GRAY);
  
        AprilTagDetection[] detections = detector.detect(grayMat);
  
        // have not seen any tags yet
        tags.clear();
  
        for (AprilTagDetection detection : detections) {
  
          // april tag layout stuff isnt needed
          Pose3d tagInFieldFrame; // pose from WPILib resource
  
          if(aprilTagFieldLayout.getTagPose(detection.getId()).isPresent() && detection.getDecisionMargin() > 50.) // margin < 20 seems bad; margin > 120 are good
          {
            tagInFieldFrame = aprilTagFieldLayout.getTagPose(detection.getId()).get();
          }
          else
          {
            System.out.println("bad id " + detection.getId() + " " + detection.getDecisionMargin());
            continue;
          }
          //
  
          // remember we saw this tag
          tags.add((long) detection.getId());
  
          // draw lines around the tag
          for (var i = 0; i <= 3; i++) {
            var j = (i + 1) % 4;
            var pt1 = new Point(detection.getCornerX(i), detection.getCornerY(i));
            var pt2 = new Point(detection.getCornerX(j), detection.getCornerY(j));
            Imgproc.line(mat, pt1, pt2, outlineColor, 2);
          }
  
          // mark the center of the tag
          var cx = detection.getCenterX();
          var cy = detection.getCenterY();
          var ll = 10;
          Imgproc.line(mat, new Point(cx - ll, cy), new Point(cx + ll, cy), crossColor, 2);
          Imgproc.line(mat, new Point(cx, cy - ll), new Point(cx, cy + ll), crossColor, 2);
  
          // identify the tag
          Imgproc.putText(
              mat,
              Integer.toString(detection.getId()),
              new Point(cx + ll, cy),
              Imgproc.FONT_HERSHEY_SIMPLEX,
              1,
              crossColor,
              3);
  
          // determine pose
          Transform3d pose = estimator.estimate(detection);
  
          /*
          System.out.println("RAW DATA");
          System.out.println("x - should be left to right");
          System.out.println( pose.getX());
          System.out.println("y - up and down (might be inverted)");
          System.out.println( pose.getY());
          System.out.println("z - forwrds and back");
          System.out.println( pose.getZ());
          */
          
          
  
          // These transformations are required for the correct robot pose.
          // double[] currentPos = { pose.getX(),  pose.getY(),  pose.getZ()}; // y pos seems to be relative to actual april tag height, so don't use (don't need anyway)
          // addToPosDict( detection.getId(), currentPos);
          // They arise from the tag facing the camera thus Pi radians rotated or CCW/CW flipped from the
          // mathematically described pose from the estimator that's what our eyes see. The true rotation
          // has to be used to get the right robot pose.
          pose = new Transform3d(
              new Translation3d(
                            pose.getX(),
                            pose.getY(),
                            pose.getZ()),
              new Rotation3d(
                          -pose.getRotation().getX() - Math.PI,
                          -pose.getRotation().getY(),
                           pose.getRotation().getZ() - Math.PI));
  
          System.out.println("RAW DATA (Corrected?)");
          System.out.println("x - should be left to right");
          System.out.println( pose.getX());
          System.out.println("y - up and down (might be inverted)");
          System.out.println( pose.getY());
          System.out.println("z - forwrds and back");
          System.out.println( pose.getZ());
          System.out.println("yaw angle");
          System.out.println( pose.getRotation().getZ());
          this.position[0] = pose.getX();
          this.position[1] = pose.getY();
          this.position[2] = pose.getZ();

          double[] currentPos = { pose.getX(),  pose.getY(),  pose.getZ(), pose.getRotation().getZ()};
          addToPosDict( detection.getId(), currentPos);

  
          // OpenCV and WPILib estimator layout of axes is EDN and field WPILib is NWU; need x -> -y , y -> -z , z -> x and same for differential rotations
          // pose = CoordinateSystem.convert(pose, CoordinateSystem.EDN(), CoordinateSystem.NWU());
          // WPILib convert is wrong for transforms as of 2023.4.3 so use this patch for now
         // {
          // corrected convert
          /** 
          var from = CoordinateSystem.EDN();
          var to = CoordinateSystem.NWU();
          pose = new Transform3d(
                    CoordinateSystem.convert(pose.getTranslation(), from, to),
                    CoordinateSystem.convert(new Rotation3d(), to, from)
                        .plus(CoordinateSystem.convert(pose.getRotation(), from, to)));
          // end of corrected convert
          }
          
          var // transform to camera from robot chassis center at floor level
          cameraInRobotFrame = new Transform3d(       
          //                      new Translation3d(0., 0., 0.),// camera at center bottom of robot zeros for test data 
          //                      new Rotation3d(0.0, Units.degreesToRadians(0.), Units.degreesToRadians(0.0))); // camera in line with robot chassis
                            new Translation3d(0.2, 0., 0.0),// camera in front of center of robot and above ground
                            new Rotation3d(0.0, Units.degreesToRadians(0.0), Units.degreesToRadians(0.0))); // camera in line with robot chassis
                                                                                   // y = -30 camera points up; +30 points down; sign is correct but backwards of LL
  
          var // robot in field is the composite of 3 pieces
          robotInFieldFrame = ComputerVisionUtil.objectToRobotPose(tagInFieldFrame,  pose,  cameraInRobotFrame);
          // end transforms to get the robot pose from this vision tag pose
  
          // put pose into dashboard
          Rotation3d rot = robotInFieldFrame.getRotation();
          tagsTable
              .getEntry("pose_" + detection.getId())
              .setDoubleArray(
                  new double[] {
                    robotInFieldFrame.getX(), robotInFieldFrame.getY(), robotInFieldFrame.getZ(), rot.getX(), rot.getY(), rot.getZ()
                  });
          double x = robotInFieldFrame.getX();
          double y = robotInFieldFrame.getY();
          double z = robotInFieldFrame.getZ();
          */
  
          int aprilTagId = detection.getId();
  
          if (aprilTagId == 1 || aprilTagId ==  2 || aprilTagId ==  3 || aprilTagId == 4) {
  
            //this.position[0] = -(this.position[0] - 15);
          }
  
          // Pushes the data fetched from an AprilTag to Shuffleboard
  
          SmartDashboard.putNumber("Distance", this.position[2]);
          SmartDashboard.putNumber("Left or Right", this.position[0]);
          SmartDashboard.putNumber("Camera Angle", this.position[1]);
  
        }
  
        // put list of tags onto dashboard
        pubTags.set(tags.stream().mapToLong(Long::longValue).toArray());
  
        // Give the output stream a new image to display
        outputStream.putFrame(mat);
      }
  
      pubTags.close();
      detector.close();
    }
    
    @Override
    public void robotInit() {
        var visionThread = new Thread(() -> apriltagVisionThreadProc());
        visionThread.setDaemon(true);
        visionThread.start();
    }

    @Override
    public void robotPeriodic() {}

    @Override
    public void autonomousInit() {
      //gyro = new ADXRS450_Gyro();
      gyro.reset();
      System.out.println("Id " + neededTagsPerTeam[currentTeam][0]);
      double[] aprilPos = readPosDict(neededTagsPerTeam[currentTeam][0]);
      double angToPos = Math.atan2(aprilPos[0] , aprilPos[2]);
      System.out.println(angToPos);
      //alignToAngle = angToPos - gyro.getAngle();
      //alignToAngle = aprilPos[3] - 0;
      autoTimer.reset();
      autoTimer.start();
    }

    @Override
    public void autonomousPeriodic() {
        /*
        motorL1.set(ControlMode.PercentOutput, .2);
        motorL2.set(ControlMode.PercentOutput, .2);

        motorR1.set(ControlMode.PercentOutput, -.2);
        motorR2.set(ControlMode.PercentOutput,-.2);
         */
        /*
        double LSSpeed = 0.2;
        double RSSpeed = 0.2;
        tank(LSSpeed, RSSpeed);
        */
        //double[] neededPos = readPosDict(neededTagsPerTeam[currentTeam][1]);
        //System.out.println("getting pos for " + neededTagsPerTeam[currentTeam][1]);
        //System.out.println(Arrays.toString(neededPos));
        //autoAim(0, 0, 0);
        //arcade(LSSpeed, 0);// trun angle in arcade dirve should vary from -1 to 1, automatically converts to angle
        //pointNShoot(90, 0, LSSpeed); // give angle in degrees (can be made for rad)
        System.out.println("timer " + autoTimer.get());
        System.out.println("stage = " + autoStage);
        if(autoTimer.get() <= 1.5){
          System.out.println("MARCH FORWARDS!");
          arcade(0.3, 0);
        }
        else{
          if(autoStage == 1 && false){
            // turn 180 or something
            autoStage = 2;
          }
          else if (autoStage == 2) {
              System.out.println("ALIGN TO TAG!!!!");
              //alignToAngleFunc(gyro.getAngle());
              System.out.println("Id " + neededTagsPerTeam[currentTeam][0]);
              double[] aprilPos = readPosDict(neededTagsPerTeam[currentTeam][0]);
              double angToPos = Math.atan2(aprilPos[0] , aprilPos[2]);
              System.out.println("april angle " + angToPos);
              System.out.println(" yaw " + aprilPos[3]);
              alignInit(aprilPos[3]);
              if ( alignToAngleFunc(gyro.getAngle()) == true ){
                // change mode or something
                autoStage = 3;
              }
          }
          else if (autoStage == 3){
            // shoot
            System.out.println("SHOOT!");
          }

        }
          
    }


    @Override
    public void teleopInit() {}

    @Override
    public void teleopPeriodic() {
        // Point and shoot steering implementation
        // get joystick vals
        double joyX = flightStick.getRawAxis(0);
        double joyY = flightStick.getRawAxis(1);
        double gyroAngle = gyro.getAngle();
        gyroAngle =modulo(gyroAngle, 360); // now angle will range from -180 to 180
        double[] polarJoy = getPolarSqr(joyX, -joyY);
        
        pointNShoot(polarJoy[1], gyroAngle, polarJoy[0]);
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        SmartDashboard.putNumber("Joystick Angle", polarJoy[1]);
        
        // example auto aim implementation
        double aprilTagX = position[2];
        double aprilTagY = position[1];
        double aprilTagZ = position[0];
        // may need to edit above vars, need measurment in meters
        boolean autoButton = flightStick.getRawButtonPressed(2);//?
        boolean autoAimOn = false;
        if (autoAimOn && autoButton){
            autoAimOn = false;
        }
        else if (!autoAimOn && autoButton){
            autoAimOn = true;
        }

        if (autoAimOn){
            autoAim(aprilTagX, aprilTagZ, aprilTagY);
        }
    }

    @Override
    public void disabledInit() {}

    @Override
    public void disabledPeriodic() {}

    @Override
    public void testInit() {}

    @Override
    public void testPeriodic() {}

    @Override
    public void simulationInit() {}

    @Override
    public void simulationPeriodic() {}
}
