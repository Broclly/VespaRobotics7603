// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.VictorSPX;
/*
you need these files in the vendordeps for phoenix
https://maven.ctr-electronics.com/release/com/ctre/phoenix/Phoenix5-frc2024-latest.json
https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-frc2024-latest.json
*/
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.Joystick;


import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkLowLevel.MotorType;

import java.util.ResourceBundle.Control;

import edu.wpi.first.wpilibj.Timer;

/**
 * The VM is configured to automatically run this class, and to call the functions corresponding to
 * each mode, as described in the TimedRobot documentation. If you change the name of this class or
 * the package after creating this project, you must also update the build.gradle file in the
 * project.
 */
public class Robot extends TimedRobot {
  /**
   * This function is run when the robot is first started up and should be used for any
   * initialization code.
   */
  VictorSPX driveLeftSpark = new VictorSPX(1);
  VictorSPX driveRightSpark = new VictorSPX(3);
  VictorSPX driveLeftVictor = new VictorSPX(2);
  VictorSPX driveRightVictor = new VictorSPX(4);
  Joystick newJoystick = new Joystick(0);

  CANSparkMax armMotor = new CANSparkMax(1, MotorType.kBrushless);
  //CANSparkMax shooterMotorBase = new CANSparkMax(2, MotorType.kBrushless);
  CANSparkMax shooterMotor1 = new CANSparkMax(3, MotorType.kBrushed);
  CANSparkMax shooterMotor2 = new CANSparkMax(4, MotorType.kBrushed);
  // Add a variable to track whether the turn button was pressed in the previous iteration
  private boolean previousButtonState = false;

  Timer autoTimer = new Timer();


  // Timer to control the duration of the turn
  private double turnStartTime = 0.0;
  private double turnDuration = 2.0; // Adjust the duration as needed
  private double autonomousStartTime;

  @Override
  public void robotInit() {
    CameraServer.startAutomaticCapture();
  
    // We need to invert one side of the drivetrain so that positive voltages
    // result in both sides moving forward. Depending on how your robot's
    // gearbox is constructed, you might have to invert the left side instead.

  }

  @Override
  public void robotPeriodic() {
    //System.out.println("I AM RUNNING -t5");
  }

  @Override
  public void autonomousInit() {
    // Add any initialization code for autonomous mode here.
    autonomousStartTime = Timer.getFPGATimestamp();
    autoTimer.restart();
    autoTimer.start();

  }

  @Override
  public void autonomousPeriodic() {
    //double timeElapsed = Timer.getFPGATimestamp() - autonomousStartTime;
    double timeElapsed = autoTimer.get();
    System.out.println(timeElapsed);
    double jerk1 = 0.2;
    double jerk2 = jerk1 + 0.2;
    double p1Time = jerk2 + 4;// rev top motor
    double p2Time = p1Time + 1; // shoot note
    double p3Time = p2Time + 3;// backup
    double jerkSpeed = 0.8;
    //double p4Time = 3;// backup?
    /*
    if (timeElapsed < jerk1 ){

        //driveLeftSpark.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveLeftVictor.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveRightVictor.set(ControlMode.PercentOutput, jerkSpeed);
        //driveRightSpark.set(ControlMode.PercentOutput, jerkSpeed);
  
    }
    else if(timeElapsed <jerk2){
        //driveLeftSpark.set(ControlMode.PercentOutput, jerkSpeed);
        //driveLeftVictor.set(ControlMode.PercentOutput, jerkSpeed);
        //driveRightVictor.set(ControlMode.PercentOutput, -jerkSpeed);
        //driveRightSpark.set(ControlMode.PercentOutput, -jerkSpeed);
    }
    else if (timeElapsed < p1Time ){
        //shooterMotor2.set(-5);
        //driveLeftSpark.set(ControlMode.PercentOutput, 0);
        //driveLeftVictor.set(ControlMode.PercentOutput, 0);
        //driveRightVictor.set(ControlMode.PercentOutput, 0);
        //driveRightSpark.set(ControlMode.PercentOutput, 0);

    } 
    else if(timeElapsed < p2Time){
      //shooterMotor1.set(-5);
      //shooterMotor2.set(-5);
    }
    */

    if(timeElapsed < 3){   
      driveLeftSpark.set(ControlMode.PercentOutput, -0.5);
      driveLeftVictor.set(ControlMode.PercentOutput, -0.5);
      driveRightVictor.set(ControlMode.PercentOutput, 0.5);
      driveRightSpark.set(ControlMode.PercentOutput, 0.5);
    } 
    else{
      driveLeftSpark.set(ControlMode.PercentOutput, 0);
      driveLeftVictor.set(ControlMode.PercentOutput, 0);
      driveRightVictor.set(ControlMode.PercentOutput, 0);
      driveRightSpark.set(ControlMode.PercentOutput, 0);
      //shooterMotor1.set(0);
      //shooterMotor2.set(0);
    }
  }

  @Override
  public void teleopInit() {
    System.out.println("teleop");
  }

  @Override
  public void teleopPeriodic() {
    //System.out.println("Running");
    double x_ampl = newJoystick.getRawAxis(1);
    double y_ampl = newJoystick.getRawAxis(0);
    double leftSpeed = (-x_ampl + y_ampl);
    double rightSpeed = (y_ampl + x_ampl);
    
    
    if (newJoystick.getRawButton(12)){
      armMotor.set(1);
    }else if(newJoystick.getRawButton(11)){
      armMotor.set(-1);
    }else{
      armMotor.set(0);
    }

    if (newJoystick.getRawButton(1)){
      shooterMotor1.set(-1);
      shooterMotor2.set(-1);

      //System.out.println("shoot");
    }
    else if (newJoystick.getRawButton(2)){
      shooterMotor1.set(1);
      shooterMotor2.set(1);
      //System.out.println("intake");
    
    }  
    else if(newJoystick.getRawButton(6)){
      shooterMotor2.set(-1);
    }
    else{
      shooterMotor1.set(0);
      shooterMotor2.set(0);
    }
    /*
    if (newJoystick.getRawButton(5)){
      shooterMotorBase.set(1);
    }
    else if(newJoystick.getRawButton(3)){
      shooterMotorBase.set(-1);
    }
    else{
      shooterMotorBase.set(0);
    }*/

    if (leftSpeed > 1) {
      leftSpeed = leftSpeed / 3;
    }

    if (rightSpeed > 1) {
      rightSpeed = rightSpeed / 3;   
    }



    // Update the previous button state for the next iteration

    driveLeftSpark.set(ControlMode.PercentOutput, leftSpeed);
    driveLeftVictor.set(ControlMode.PercentOutput, leftSpeed);
    driveRightVictor.set(ControlMode.PercentOutput, rightSpeed);
    driveRightSpark.set(ControlMode.PercentOutput, rightSpeed);
  }

  @Override
  public void disabledInit() {}

  @Override
  public void disabledPeriodic() {}

  @Override
  public void testInit() {}

  @Override
  public void testPeriodic() {}

  @Override
  public void simulationInit() {}

  @Override
  public void simulationPeriodic() {}
}
